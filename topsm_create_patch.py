################################################################################
# TopSM Patch Generator
# Created by Robert Pafford (rjp5th)
#
# Converts a TopSM binary into a MCE/RFE Patch
# The output filename should follow the convention rf_patch_mce_patchname.h
#
# SPDX-FileCopyrightText: 2024 Robert Pafford
# SPDX-License-Identifier: MIT
################################################################################

import re
import os
import sys
import datetime

def write_header(fout, infile, filename, ts: 'datetime.datetime'):
    fout.write(f"/******************************************************************************\n")
    fout.write(f"*\n")
    fout.write(f"* Filename: {filename}\n")
    fout.write(f"*\n")
    fout.write(f"* This file was created using the TopSM Assembler\n")
    fout.write(f"* Autogenerated from {infile}\n")
    fout.write(f"*\n")
    fout.write(f"* Generated on {ts.strftime('%Y-%m-%d %H:%M:%S%z')}\n")
    fout.write(f"*\n")
    fout.write(f"******************************************************************************/\n")
    fout.write("\n")

def create_default_define(fout, name, value):
    fout.write(f"#ifndef {name}\n")
    fout.write(f"#define {name} {value}\n")
    fout.write(f"#endif\n\n")

def gen_patch_files(infile: str, outfile: str, patchtype = "MCE"):
    if patchtype is not None:
        patchtype = patchtype.upper()

    # Determine type from input filename
    patch_prefix = "rf_patch_"
    detpatchtype = None
    if infile.startswith(patch_prefix):
        infile_segments = infile[len(patch_prefix):].split("_")
        if len(infile_segments) > 1:
            detpatchtype = infile_segments[0].upper()
            if patchtype is None:
                patchtype = detpatchtype
            elif patchtype != detpatchtype:
                print(f"[WARNING] Detected patch type {detpatchtype} does not match provided patch type {patchtype}. Using provided type", file=sys.stderr)

    if detpatchtype is None and patchtype is None:
        print("[ERROR] No patch type provided (MCE/RFE) and unable to detect patch type from filename\n")
        sys.exit(1)

    # Generate identifier from input filename
    identifier,_ = os.path.splitext(os.path.basename(infile))
    identifier = re.sub(r"[^A-Za-z0-9_]", "_", identifier).lower()
    expected_identifier_prefix = f"{patch_prefix}{patchtype.lower()}_"

    if not identifier.startswith(expected_identifier_prefix):
        identifier = expected_identifier_prefix + identifier

    # Convert identifier to c array name for patch
    c_array_name = "patch"
    nextIsUpper = True
    for c in identifier[len(expected_identifier_prefix):]:
        if c == "_":
            nextIsUpper = True
        else:
            if nextIsUpper:
                c_array_name += c.upper()
                nextIsUpper = False
            else:
                c_array_name += c.lower()
    c_array_name += patchtype[0].upper() + patchtype[1:].lower()

    # Determine the patch base
    if patchtype == "MCE":
        patchbase = 0x21008000
    elif patchtype == "RFE":
        patchbase = 0x2100C000
    else:
        print(f"[ERROR] Invalid patch type {patchtype}. Expected either RFE or MCE", file=sys.stderr)
        return 1

    # Determine output filenames from the provided outfile path
    if os.path.isdir(outfile):
        hdrfile = os.path.join(outfile, identifier + ".h")
        outfile = os.path.join(outfile, identifier + ".c")
    else:
        if os.path.basename(outfile) == identifier + ".h":
            print(f"[NOTE] Although this generates both the .h and .c files, you should set the output file to the .c one", file=sys.stderr)
            hdrfile = outfile
            outfile = os.path.splitext(outfile)[0] + ".c"
        elif os.path.basename(outfile) != identifier + ".c":
            print(f"[WARNING] Output filename does not match the expected name '{identifier}.h'", file=sys.stderr)
            hdrfile = os.path.splitext(outfile)[0] + ".h"
        else:
            hdrfile = os.path.splitext(outfile)[0] + ".h"

    gentime = datetime.datetime.now().astimezone()

    # Read in the input into an array of words
    patch_words = []
    with open(infile, "rb") as f:
        while True:
            dat = f.read(4)
            if len(dat) == 0:
                break
            patch_words.append(int.from_bytes(dat, 'little'))

    if len(patch_words) == 0 or len(patch_words) > 2048:
        print("[ERROR] Invalid patch file size (either empty or longer than 2048 words)", file=sys.stderr)
        return 1

    with open(outfile, "w") as fout, open(hdrfile, "w") as hdrout:
        write_header(fout, infile, identifier + ".c", gentime)
        fout.write("\n")
        fout.write("#include <stdint.h>\n")
        fout.write(f"#include \"{identifier}.h\"\n")
        fout.write("#include <ti/devices/DeviceFamily.h>\n")
        fout.write("#include DeviceFamily_constructPath(inc/hw_types.h)\n")
        fout.write("\n")
        create_default_define(fout, f"{patchtype}_PATCH_TYPE", "static const uint32_t")
        create_default_define(fout, "PATCH_FUN_SPEC", "")
        create_default_define(fout, f"RFC_{patchtype}RAM_BASE", "0x{:08X}".format(patchbase))
        create_default_define(fout, f"{patchtype}_PATCH_MODE", "0")

        fout.write(f"{patchtype}_PATCH_TYPE {c_array_name}[{len(patch_words)}] = ")
        fout.write("{\n   ")
        fout.write(",\n   ".join(map(lambda x: "0x{:08X}".format(x), patch_words)))
        fout.write("\n};\n\n")

        fout.write(f"PATCH_FUN_SPEC void {identifier}(void)\n")
        fout.write("{\n")
        fout.write("   uint32_t i;\n")
        fout.write("   for (i = 0; i < %d; i++) {\n" % len(patch_words))
        fout.write(f"      HWREG(RFC_{patchtype}RAM_BASE + 4 * i) = {c_array_name}[i];\n")
        fout.write("   }\n")
        fout.write("}\n")

        write_header(hdrout, infile, identifier + ".h", gentime)
        hdrout.write(f"#ifndef _{identifier.upper()}_H\n")
        hdrout.write(f"#define _{identifier.upper()}_H\n")
        hdrout.write("\n")
        hdrout.write("#include <stdint.h>\n")
        hdrout.write("#include <ti/devices/DeviceFamily.h>\n")
        hdrout.write("#include DeviceFamily_constructPath(inc/hw_types.h)\n")
        hdrout.write("\n")
        hdrout.write(f"extern void {identifier}(void);\n")
        hdrout.write("\n")
        hdrout.write("#endif\n")

    return 0

if __name__ == "__main__":
    if len(sys.argv) < 3 or len(sys.argv) > 4:
        print("Invalid Syntax! Usage:\n")
        print(f"{sys.argv[0]} [infile] [outfile] [patch type (optional, only needed if not part of input filename)]")
        sys.exit(1)
    if len(sys.argv) == 4:
        patchtype = sys.argv[3]
    else:
        patchtype = None
    sys.exit(gen_patch_files(sys.argv[1], sys.argv[2], patchtype))
